C51 COMPILER V9.54   LED                                                                   10/12/2020 17:32:43 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE LED
OBJECT MODULE PLACED IN .\output\led.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE led.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\listing\led.ls
                    -t) OBJECT(.\output\led.obj)

line level    source

   1          #include <reg51.h> 
   2          #include <intrins.h>
   3          #define  NOP() _nop_()  /* 定义空指令 */
   4          
   5          /*
   6          //共阳极  (这里是标准的)
   7          unsigned char code LED_0F[] = 
   8          {// 0    1        2        3    4        5        6        7    8        9        A        b    C    d    E    F    -
   9                  0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0x8C,0xBF,0xC6,0xA1,0x86,0xFF,0xbf
  10          };
  11          
  12          */
  13          
  14          //共阳极（单独写的，不标准）
  15          unsigned char code LED_0F[] = 
  16          {
  17          /*0,1,2,3,4,5,6,7,8,9,A,b,C,d,E,F,-,*/
  18              0x82,0xFA,0x46,0x52,0x3A,0x13,0x03,0xDA,0x02,0x12,0x0A,0x23,0x87,0x62,0x07,0x0F,0x7F,
  19          };
  20          
  21          // 函数原形定义
  22          #define uchar unsigned char
  23                  
  24          
  25          void OUT_595(void);
  26          void WR_595(unsigned char SendVal);
  27          void display_num(void);
  28          void disp_init();
  29          uchar out_calc(uchar xian);
  30          
  31          
  32          unsigned char code LED_0F[];            // LED字模表
  33          uchar second,dp_num=0;
  34          
  35          sbit MOSIO = P1^2;                              //串行数据输入
  36          sbit R_CLK  = P1^0;                             //时钟脉冲信号――上升沿有效
  37          sbit S_CLK = P1^1;                              //打入信号――――上升沿有效
  38          
  39          //-----------------------------------------------------------------------------
  40          // 全局变量
  41          uchar LED[8];   //用于LED的8位显示缓存
  42          
  43          uchar temp; 
  44          
  45          //*****************************************************************************
  46          // 主程序
  47          //
  48          void main (void) 
  49          {
  50   1              TMOD=0X01; //T0工作方式1
  51   1              TH0=(65536-10000)/256;
  52   1              TL0=(65536-10000)%256;   //10毫秒中断一次
  53   1              EA=1;
  54   1              ET0=1;
C51 COMPILER V9.54   LED                                                                   10/12/2020 17:32:43 PAGE 2   

  55   1              TR0=1;
  56   1              
  57   1              disp_init();
  58   1      
  59   1              
  60   1              while(1)
  61   1              {
  62   2                      
  63   2              }
  64   1              
  65   1      
  66   1      }
  67          
  68          
  69          void T0_SEVR() interrupt 1
  70          {
  71   1              int i;
  72   1              TH0=(65536-40000)/256;
  73   1              TL0=(65536-40000)%256;
  74   1              second++;
  75   1              if(second==20)
  76   1              {
  77   2                      second=0;
  78   2                      for(i=0;i<8;i++)
  79   2                              LED[i]=dp_num%17;
  80   2                      dp_num++;
  81   2                      if(dp_num>100)
  82   2                              dp_num=0;
  83   2              }
  84   1      
  85   1              display_num();
  86   1      
  87   1      }
  88          
  89          void disp_init()
  90          {
  91   1              LED[0]=1;
  92   1              LED[1]=2;
  93   1              LED[2]=3;
  94   1              LED[3]=4;
  95   1              LED[4]=13;
  96   1              LED[5]=12;
  97   1              LED[6]=14;
  98   1              LED[7]=15;
  99   1      
 100   1              S_CLK = 0;
 101   1              R_CLK = 1; 
 102   1      }
 103          void display_num(void)
 104          {       
 105   1              
 106   1      
 107   1              WR_595(out_calc(0));                     //输入8位
 108   1              WR_595(out_calc(1));                     //输入8位
 109   1              WR_595(out_calc(2));                     //输入8位
 110   1              WR_595(out_calc(3));                     //输入8位
 111   1              WR_595(out_calc(4));                     //输入8位
 112   1              WR_595(out_calc(5));                     //输入8位
 113   1              WR_595(out_calc(6));                     //输入8位
 114   1              WR_595(out_calc(7));                     //输入8位
 115   1              
 116   1              OUT_595();                       //锁存并输出
C51 COMPILER V9.54   LED                                                                   10/12/2020 17:32:43 PAGE 3   

 117   1      
 118   1      }
 119          
 120          uchar out_calc(uchar xian)
 121          {
 122   1              unsigned char code *led_table;          // 查表指针
 123   1              led_table = LED_0F + LED[xian];
 124   1              temp = *led_table;
 125   1              return temp;
 126   1      }
 127          
 128          
 129          void WR_595(unsigned char SendVal)
 130          {  
 131   1        unsigned char i;
 132   1                      
 133   1        for(i=0;i<8;i++) 
 134   1         {
 135   2              if((SendVal<<i)&0x80) MOSIO=1; //set dataline high  0X80  最高位与SendVal左移的最高位 进行逻辑运算
 136   2              else MOSIO=0;                              // 如果为真 MOSIO = 1  
 137   2       
 138   2              S_CLK=1;  //上升沿发生移位
 139   2              NOP();   //短暂延时产生一定宽度的脉冲信号
 140   2              NOP();   //短暂延时
 141   2              S_CLK=0;
 142   2                      
 143   2         }
 144   1      
 145   1      }
 146          
 147          
 148          
 149          /********************************************************/
 150          /*                                                      */
 151          /*将移位寄存器内的数据锁存到输出寄存器并显示            */
 152          /*                                                      */
 153          /********************************************************/
 154           void OUT_595(void)
 155          {
 156   1              R_CLK=0; //set dataline low
 157   1              NOP();  //短暂延时
 158   1              NOP();  //短暂延时
 159   1              R_CLK=1;         //上升沿将数据送到输出锁存器
 160   1              NOP();  //短暂延时
 161   1              NOP();  //短暂延时
 162   1              R_CLK=0;
 163   1      }
 164          
 165          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    292    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
